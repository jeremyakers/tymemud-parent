#!/usr/bin/env python3
"""
Ubermap autopilot checks (no external deps).

Goal: provide deterministic, scriptable safety nets so we stop spinning:
- Track seed_bug direction mismatches (should trend to 0 for macro overland)
- Track Tar Valon overlap proxy (macro tile centers inside zone-90 bbox)
- Track specific corridor health (468/486 bridge chain)

Designed to run against exports generated by genwld.c:
  MM32/lib/ubermap_coords_468_640_pluslinked.tsv
  MM32/lib/ubermap_direction_mismatch_classified_468_640_pluslinked.tsv

Example:
  scripts/ubermap_autopilot_check.py --lib MM32/lib
  scripts/ubermap_autopilot_check.py --lib MM32/lib --prev metrics.json
"""

from __future__ import annotations

import argparse
import csv
import json
import os
import sys
from dataclasses import dataclass
from typing import Dict, Iterable, List, Optional, Tuple


@dataclass(frozen=True)
class Metrics:
    seed_bug_total: int
    seed_bug_468_486: int
    tar_valon_macro_tiles_inside_bbox: int
    tar_valon_exact_macro_overlaps: int
    tar_valon_physical_bug_edges: int
    tar_valon_bbox: Tuple[int, int, int, int]  # minx,maxx,miny,maxy (zones 90-92)

    def to_json(self) -> Dict[str, object]:
        return {
            "seed_bug_total": self.seed_bug_total,
            "seed_bug_468_486": self.seed_bug_468_486,
            "tar_valon_macro_tiles_inside_bbox": self.tar_valon_macro_tiles_inside_bbox,
            "tar_valon_exact_macro_overlaps": self.tar_valon_exact_macro_overlaps,
            "tar_valon_physical_bug_edges": self.tar_valon_physical_bug_edges,
            "tar_valon_bbox": list(self.tar_valon_bbox),
        }


def read_tsv(path: str) -> Iterable[Dict[str, str]]:
    with open(path, "r", encoding="utf-8", newline="") as f:
        r = csv.DictReader(f, delimiter="\t")
        for row in r:
            yield row


def compute_tar_valon_bbox(coords_rows: Iterable[Dict[str, str]]) -> Tuple[int, int, int, int]:
    minx = miny = None
    maxx = maxy = None
    for row in coords_rows:
        try:
            # Tar Valon is spread across zones 90-92.
            if int(row["zone"]) not in (90, 91, 92):
                continue
            x = int(row["x"])
            y = int(row["y"])
        except Exception:
            continue
        minx = x if minx is None else min(minx, x)
        maxx = x if maxx is None else max(maxx, x)
        miny = y if miny is None else min(miny, y)
        maxy = y if maxy is None else max(maxy, y)
    if minx is None or maxx is None or miny is None or maxy is None:
        return (0, 0, 0, 0)
    return (minx, maxx, miny, maxy)


def count_macro_tiles_inside_bbox(
    coords_rows: Iterable[Dict[str, str]],
    bbox: Tuple[int, int, int, int],
) -> int:
    minx, maxx, miny, maxy = bbox
    c = 0
    for row in coords_rows:
        try:
            zone = int(row["zone"])
            x = int(row["x"])
            y = int(row["y"])
            z = int(row["z"])
            physical = int(row.get("physical", "1"))
        except Exception:
            continue
        if zone < 468 or zone > 640:
            continue
        if physical != 1:
            continue
        if z != 0:
            continue
        if minx <= x <= maxx and miny <= y <= maxy:
            c += 1
    return c


def count_exact_macro_overlaps(coords_rows: Iterable[Dict[str, str]]) -> int:
    """
    Count true macroâ†”TarValon overlaps by exact coordinate collision (same x,y at z=0).

    Bounding-box overlap is too conservative for a large city footprint; this detects
    actual stacked centers which is what visually produces overprinted VNUMs.
    """
    tv_xy = set()
    macro_xy = set()

    for row in coords_rows:
        try:
            zone = int(row["zone"])
            x = int(row["x"])
            y = int(row["y"])
            z = int(row["z"])
            physical = int(row.get("physical", "1"))
        except Exception:
            continue
        if physical != 1 or z != 0:
            continue
        if zone in (90, 91, 92):
            tv_xy.add((x, y))
        if 468 <= zone <= 640:
            macro_xy.add((x, y))

    return len(tv_xy.intersection(macro_xy))


def count_tar_valon_physical_bug_edges(mis_rows: Iterable[Dict[str, str]]) -> int:
    c = 0
    for row in mis_rows:
        if row.get("class") != "physical_bug":
            continue
        try:
            fz = int(row["from_zone"])
            tz = int(row["to_zone"])
        except Exception:
            continue
        if fz in (90, 91, 92) and tz in (90, 91, 92):
            c += 1
    return c


def compute_metrics(lib_dir: str) -> Metrics:
    coords_path = os.path.join(lib_dir, "ubermap_coords_468_640_pluslinked.tsv")
    mis_path = os.path.join(lib_dir, "ubermap_direction_mismatch_classified_468_640_pluslinked.tsv")

    coords_rows_1 = list(read_tsv(coords_path))
    bbox = compute_tar_valon_bbox(iter(coords_rows_1))

    seed_bug_total = 0
    seed_bug_468_486 = 0
    for row in read_tsv(mis_path):
        if row.get("class") != "seed_bug":
            continue
        seed_bug_total += 1
        try:
            fv = int(row["from_vnum"])
            tv = int(row["to_vnum"])
        except Exception:
            continue
        if (46800 <= fv <= 46899) or (48600 <= fv <= 48699) or (46800 <= tv <= 46899) or (48600 <= tv <= 48699):
            seed_bug_468_486 += 1

    tv_overlap = count_macro_tiles_inside_bbox(iter(coords_rows_1), bbox)
    tv_exact = count_exact_macro_overlaps(iter(coords_rows_1))
    tv_phys_bugs = count_tar_valon_physical_bug_edges(read_tsv(mis_path))
    return Metrics(
        seed_bug_total=seed_bug_total,
        seed_bug_468_486=seed_bug_468_486,
        tar_valon_macro_tiles_inside_bbox=tv_overlap,
        tar_valon_exact_macro_overlaps=tv_exact,
        tar_valon_physical_bug_edges=tv_phys_bugs,
        tar_valon_bbox=bbox,
    )


def load_prev(path: str) -> Optional[Metrics]:
    try:
        with open(path, "r", encoding="utf-8") as f:
            d = json.load(f)
        bbox = d.get("tar_valon_bbox", [0, 0, 0, 0])
        return Metrics(
            seed_bug_total=int(d.get("seed_bug_total", 0)),
            seed_bug_468_486=int(d.get("seed_bug_468_486", 0)),
            tar_valon_macro_tiles_inside_bbox=int(d.get("tar_valon_macro_tiles_inside_bbox", 0)),
            tar_valon_bbox=(int(bbox[0]), int(bbox[1]), int(bbox[2]), int(bbox[3])),
        )
    except Exception:
        return None


def main() -> int:
    ap = argparse.ArgumentParser(description="Ubermap autopilot checks (no deps)")
    ap.add_argument("--lib", required=True, help="Path to MM32/lib containing ubermap_* exports")
    ap.add_argument("--prev", help="Optional path to previous metrics JSON to enforce monotonic improvement")
    ap.add_argument("--write", help="Write current metrics JSON to this path")
    ap.add_argument("--require-seed-bug-zero", action="store_true", help="Fail if seed_bug_total != 0")
    ap.add_argument("--require-tar-valon-no-overlap", action="store_true", help="Fail if macro tiles inside Tar Valon bbox != 0")
    args = ap.parse_args()

    m = compute_metrics(args.lib)
    print(json.dumps(m.to_json(), indent=2, sort_keys=True))

    if args.write:
        with open(args.write, "w", encoding="utf-8") as f:
            json.dump(m.to_json(), f, indent=2, sort_keys=True)
            f.write("\n")

    if args.prev:
        prev = load_prev(args.prev)
        if prev:
            # Monotonic improvement: seed_bug_total should not increase; Tar Valon overlap should not increase.
            if m.seed_bug_total > prev.seed_bug_total:
                print(f"REGRESSION: seed_bug_total {prev.seed_bug_total} -> {m.seed_bug_total}", file=sys.stderr)
                return 2
            if m.tar_valon_macro_tiles_inside_bbox > prev.tar_valon_macro_tiles_inside_bbox:
                print(
                    f"REGRESSION: tv_overlap {prev.tar_valon_macro_tiles_inside_bbox} -> {m.tar_valon_macro_tiles_inside_bbox}",
                    file=sys.stderr,
                )
                return 2

    if args.require_seed_bug_zero and m.seed_bug_total != 0:
        print(f"FAIL: seed_bug_total={m.seed_bug_total} (expected 0)", file=sys.stderr)
        return 3
    if args.require_tar_valon_no_overlap and m.tar_valon_macro_tiles_inside_bbox != 0:
        print(
            f"FAIL: tar_valon_macro_tiles_inside_bbox={m.tar_valon_macro_tiles_inside_bbox} (expected 0)",
            file=sys.stderr,
        )
        return 3

    return 0


if __name__ == "__main__":
    raise SystemExit(main())

